#user  nobody;
worker_processes 4;

#error_log  logs/error.log;
#error_log  logs/error.log  notice;
#error_log  logs/error.log  info;

#pid        logs/nginx.pid;

events {
    worker_connections  1024;
}

http {
	map $remote_addr $rt_filtered_ip {
		default $binary_remote_addr;
		98.184.34.4 "";
		167.99.24.104 "";
		134.209.48.248 "";
		10.120.0.12 "";
	}

	limit_req_zone $binary_remote_addr zone=one:10m rate=10r/s;

	client_max_body_size 4g;
	lua_shared_dict auto_ssl 100m;
	lua_shared_dict auto_ssl_settings 64k;

	resolver 8.8.4.4 8.8.8.8 ipv6=off;

	init_by_lua_block {
		ngx.log(ngx.ERR, "1) init_by_lua ")

		local json = require "cjson"
		local socket = assert(require "socket.unix"())

		auto_ssl = (require "resty.auto-ssl").new()
		auto_ssl:set("storage_adapter", "resty.auto-ssl.storage_adapters.redis")
		auto_ssl:set("renew_check_interval", 172800)		
		auto_ssl:set("allow_domain", function(domain)

			ngx.log(ngx.ERR, "The domain to check is: ", domain)

			-- Weed out ipaddresses. Cant get ssl for ip addresses
			local ipregex = [=[^([0-9]{1,3}\.)([0-9]{1,3}\.)([0-9]{1,3}\.)([0-9]{1,3})$]=]
			if ngx.re.match(domain, ipregex) then
				-- ngx.log(ngx.ERR, "ngx domain test 1", ngx.re.match(domain, ipregex) )
				-- ngx.log(ngx.ERR, "IP Address Match ", domain)
				return false
			end

			-- Connect to the socket and search for domain from lookuptree - using unix socket , was replaced by posix
			assert(socket:settimeout(.5))
			local status, err = pcall(function() 
				assert(socket:connect("/var/run/proxy_lookup.socket"))
			end)

			ngx.log(ngx.ERR, "socket.unix connection status ", status)
			ngx.log(ngx.ERR, "socket.unix connection err ", err)
			if status then 
				ngx.log(ngx.ERR, "socket.unix connection is made ")
				assert(socket:send(json.encode({domain = domain})))
				while 1 do
					ngx.log(ngx.ERR, "While 1 do ")
					local s, status, partial = socket:receive()
					ngx.log(ngx.ERR, "Initial FQN search partial s ", s)
					ngx.log(ngx.ERR, "Initial FQN search partial status ", status)
					ngx.log(ngx.ERR, "Initial FQN search partial partial ", partial)
					-- Initial search returns *.domain.com or *.*.domain.com when connected
					if partial then
						res = json.decode(partial)
						socket:close()
						break
					end
				end
			else
				ngx.log(ngx.ERR, "socket connection failed")
				socket:close()
				-- return false
			end

			if not domain then
				ngx.log(ngx.ERR, "No Header ")
				-- ngx.exit(499)
				return false
			end

			local redis = require "resty.redis"
			local red = redis:new()

			red:set_timeout(1000) -- 1 second

			local ok, err = red:connect("127.0.0.1", 6379)
			if not ok then
				ngx.log(ngx.ERR, "failed to connect to redis: ", err)
				return false
			end

			local res, err = red:hgetall("proxy_Host_"..domain)
			local res = red:array_to_hash(res)

			local firstResponse = json.encode(res)
			ngx.log(ngx.ERR, "init_by_lua firstResponse data ", firstResponse)
			
			-- The entire domain is present in the db, allow the domain
			if res["ip"] then
				return true
			end

			local newhost = domain
			if string.len(tostring(domain)) >= 0 then
				local webregex = [=[(\w+\b\.)(\w+\b)$]=]
				local baseDomain = ngx.re.match(domain, webregex)
				if baseDomain then
					local encoded = json.encode(baseDomain)
					local newhost = json.decode(encoded)
					-- ngx.log(ngx.ERR,"newhost ", newhost["0"])  
					res, err = red:hgetall("proxy_Host_"..newhost["0"])
					res = red:array_to_hash(res)
				end
			end

			local secondResponse = json.encode(res)
			ngx.log(ngx.ERR, "init_by_lua secondResponse data ", secondResponse)

			-- Find out how many stars the domain has in redis, then allow up to that many subdomains to be approved.
			-- ngx.log(ngx.ERR, "res partial", json.encode(res))

			if not res["ip"] then
				ngx.log(ngx.ERR, "No Host Found ", domain)
				-- ngx.exit(406)
				return false			
			end

			ngx.log(ngx.ERR, "allow_domain true ", domain)
			return true

		end)

		auto_ssl:init()
	}

	init_worker_by_lua_block {
		auto_ssl:init_worker()
	}

	ssl_session_cache   shared:SSL:10m;
	ssl_session_timeout 10m;

	server {
		listen 127.0.0.1:8999;

		# Increase the body buffer size, to ensure the internal POSTs can always
		# parse the full POST contents into memory.
		client_body_buffer_size 128k;
		client_max_body_size 128k;

		location / {
			content_by_lua_block {
				auto_ssl:hook_server()
			}
		}
	}

	include       mime.types;
	default_type  application/octet-stream;

	#log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
	#                  '$status $body_bytes_sent "$http_referer" '
	#                  '"$http_user_agent" "$http_x_forwarded_for"';

	access_log /var/log/nginx/access.log;
	error_log /var/log/nginx/error.log;

	sendfile        on;
	#tcp_nopush     on;

	#keepalive_timeout  0;
	keepalive_timeout  65;

	#gzip  on;
	include sites-enabled/*;

}
