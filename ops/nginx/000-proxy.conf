map $http_upgrade $connection_upgrade {
  default Upgrade;
  '' close;
}

server {
  listen 80;
  include autossl.conf;

  set_real_ip_from 192.168.1.0/24;
  real_ip_header X-Real-IP;
  real_ip_recursive on;

	location / {
		limit_req zone=one burst=100 nodelay;

		set $target '';
		set $target_scheme 'http';
		set $target_port '';
		set $header_host $host;

		access_by_lua_block {

			local json = require("cjson")
			local socket = require("posix.sys.socket")
			local unistd = require("posix.unistd")
			local redis = require("resty.redis")
			local requests = require("resty.requests")

			local host = ngx.var.host
			local uri = ngx.var.uri
			local scheme = ngx.var.scheme

			ngx.log(ngx.ERR, " --------- access_by_lua_block host ", host)

			-- ngx.log(ngx.ERR, "000-proxy ngx: ", json.encode(ngx.var))
			-- ngx.log(ngx.ERR,"uri ", uri)
			-- ngx.log(ngx.ERR,"scheme ", scheme)

			if not host then
				ngx.log(ngx.ERR, "No Base Host Found")
				return ngx.exit(404)
			end

			-- Connect to redis
			local red = redis:new()
			red:set_timeout(1000)

			local ok, err = red:connect("127.0.0.1", 6379)
			if not ok then
				ngx.log(ngx.ERR, "failed to connect to redis: ", err)
				return ngx.exit(598)
			end

			local res, err = red:hgetall("proxy_Host_"..host)
			local res = red:array_to_hash(res)

			--ngx.log(ngx.ERR, "res: ", json.encode(res))

			if res["ip"] then
				if res["targetssl"] == "true" then
					ngx.var.target_scheme = "https"
				end

				if res["host-pass-though"] == "false" then
					ngx.var.header_host = res["ip"]
				end

				ngx.var.target = res["ip"]
				ngx.var.target_port = res["targetPort"]

				if (scheme == "http") then
					if res["forcessl"] == "true" then
						return ngx.redirect("https://"..host..uri, 301)
					end
				end
				return
			end

			-- Not in redis, need to check wildcards
			-- New posx socket to check tree
			local res = nil
			local decoded = nil
			local fd = assert(socket.socket(socket.AF_UNIX, socket.SOCK_STREAM, 0))
			assert(socket.connect(fd, {family = socket.AF_UNIX, path = "/var/run/proxy_lookup.socket"}))
			assert(socket.send(fd, json.encode({domain = host})))
			while 1 do
				-- ngx.log(ngx.ERR, "While 1 do posx socket")
				-- Search returns FQN, *.host.com or *.*.host.com when connected
				local response, err, errnum = socket.recv(fd, 10000)
				ngx.log(ngx.ERR, "posx socket response ", response)
				
				decoded = json.decode(response)
				-- ngx.log(ngx.ERR, "posx socket decoded ", type(decoded))

				if decoded then
					break
				end
			end
			unistd.close(fd)

			ngx.log(ngx.ERR, "decoded response ", json.encode(decoded))

			if ( decoded and decoded["host"] == "none") then
				ngx.log(ngx.ERR, "decoded the host is none ")
					ngx.exit(404)
			end

			if not decoded["ip"] then
				ngx.log(ngx.ERR, "No Host Found ", host)
				return ngx.exit(406)
			end

			-- Check wildcards of host vs socket response
			local wildregex = [=[^(\*\.)?+]=]
			local wildcards = ngx.re.match(decoded["host"], wildregex)
			local count = #wildcards

			-- Determine qty of subdomains on request
			local subcount = 0
			for word in string.gmatch(host, '([^.]+)') do
				subcount = subcount + 1
			end
			if( subcount - 2 > count ) then
				ngx.log(ngx.ERR, "more domains than wildcards ")
				return ngx.exit(404)
			end

			if decoded["targetssl"] == "true" then
				ngx.var.target_scheme = "https"
			end

			if decoded["host-pass-though"] == "false" then
				ngx.var.header_host = decoded["ip"]
			end

			ngx.var.target = decoded["ip"]
			ngx.var.target_port = decoded["targetPort"]

			if (scheme == "http") then
				if decoded["forcessl"] == "true" then
					return ngx.redirect("https://"..host..uri, 301)
				end
			end
		
	

			

		

		
		}
			resolver 192.168.1.1 ipv6=off;  #8.8.4.4;  # use Google's open DNS server

			proxy_ssl_server_name on;
			proxy_http_version 1.1;
			proxy_pass_request_headers on;
			proxy_pass $target_scheme://$target:$target_port;

			proxy_set_header Upgrade $http_upgrade;
			proxy_set_header Connection $connection_upgrade;
			proxy_ssl_session_reuse on;

			proxy_set_header Host $header_host;
			add_header X-Target-Host $target;
			proxy_set_header X-Real-IP $remote_addr;
			proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
			proxy_set_header X-Forwarded-Proto $target_scheme;
			proxy_set_header Referer $target_scheme://$header_host;
			proxy_set_header Accept-Language $http_accept_language;
			proxy_set_header User-Agent $http_user_agent;

			sub_filter $target $host;
			sub_filter_once off;
	}	
}
