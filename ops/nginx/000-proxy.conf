map $http_upgrade $connection_upgrade {
  default Upgrade;
  '' close;
}

limit_conn_zone $binary_remote_addr zone=addr:10m;
limit_conn addr 10;

server {
  listen 80;

  include autossl.conf;

  set_real_ip_from 192.168.1.0/24;
  real_ip_header X-Real-IP;
  real_ip_recursive on;

	location / {
		limit_req zone=one burst=50 nodelay;

		set $target '';
		set $target_scheme 'http';
		set $target_port '';
		set $header_host $host;

		rewrite_by_lua_block {
			ngx.log(ngx.ERR, "---------- rewrite_block ---------- ", ngx.var.host)
			
		}
		
		# I can use $res to ngx.exit() if the return is a 404 here

		access_by_lua_block {
			local json = require("cjson")
			local socket = require("posix.sys.socket")
			local unistd = require("posix.unistd")
			local redis = require("resty.redis")

			local host = ngx.var.host
			local uri = ngx.var.uri
			local scheme = ngx.var.scheme

			ngx.log(ngx.ERR, " ********** access_by_lua_block host ", host)

			-- ngx.log(ngx.ERR, "000-proxy ngx: ", json.encode(ngx.var))
			ngx.log(ngx.ERR,"uri ", uri)
			ngx.log(ngx.ERR,"scheme ", scheme)

			-- Connect to redis
			local red = redis:new()
			red:set_timeout(1000)

			local ok, err = red:connect("127.0.0.1", 6379)
			if not ok then
				ngx.log(ngx.ERR, "failed to connect to redis: ", err)
				return ngx.exit(598)
			end

			local res = nil
			if string.len(tostring(ngx.var.host)) >= 0 then
				local webregex = [=[(\w+\b\.)(\w+\b)$]=]
				local baseDomain = ngx.re.match(host, webregex)
				if baseDomain then
					local encoded = json.encode(baseDomain)
					local host = json.decode(encoded)
					ngx.log(ngx.ERR, "base host ", host["0"])  
					local response, err = red:hgetall("proxy_Host_"..host["0"])
					res = red:array_to_hash(response)
				end
			end

			ngx.log(ngx.ERR,"- redis response 000-proxy - ", json.encode(res)) 

			if not host then
				ngx.log(ngx.ERR, "No Base Host Found")
				return ngx.exit(499)
			end

			if not res["ip"] then
				ngx.log(ngx.ERR, "No Host Found ", host)
				return ngx.exit(406)
			end

			if res["targetssl"] == "true" then
				ngx.var.target_scheme = "https"
			end

			if res["host-pass-though"] == "false" then
				ngx.var.header_host = res["ip"]
			end

			ngx.var.target = res["ip"]
			ngx.var.target_port = res["targetPort"]

			-- if (scheme == "http") then
				-- if res["forcessl"] == "true" then
					-- return ngx.redirect("https://"..host..uri, 301)
				-- end
			-- end
		}
			resolver 192.168.1.1 ipv6=off;  #8.8.4.4;  # use Google's open DNS server

			proxy_ssl_server_name on;
			proxy_http_version 1.1;
			proxy_pass_request_headers on;
			proxy_pass $target_scheme://$target:$target_port;

			proxy_set_header Upgrade $http_upgrade;
			proxy_set_header Connection $connection_upgrade;
			proxy_ssl_session_reuse on;

			proxy_set_header Host $header_host;
			add_header X-Target-Host $target;
			proxy_set_header X-Real-IP $remote_addr;
			proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
			proxy_set_header X-Forwarded-Proto $target_scheme;
			proxy_set_header Referer $target_scheme://$header_host;
			proxy_set_header Accept-Language $http_accept_language;
			proxy_set_header User-Agent $http_user_agent;

			sub_filter $target $host;
			sub_filter_once off;
	}	
}
