worker_processes 4;

events {
	worker_connections 1024;
}

http {
	map $remote_addr $rt_filtered_ip {
		default $binary_remote_addr;
		98.184.34.4 "";
		167.99.24.104 "";
		134.209.48.248 "";
		10.120.0.12 "";
	}

	limit_req_zone $binary_remote_addr zone=one:10m rate=10r/s;

	client_max_body_size 4g;
	lua_shared_dict auto_ssl 100m;
	lua_shared_dict auto_ssl_settings 64k;

	resolver 8.8.4.4 8.8.8.8 ipv6=off;


	init_by_lua_block {

		local json = require("cjson")
		local socket = require("posix.sys.socket")
		local unistd = require("posix.unistd")
		local redis = require("resty.redis")
		local requests = require("resty.requests")
		
		auto_ssl = (require "resty.auto-ssl").new()
		auto_ssl:set("storage_adapter", "resty.auto-ssl.storage_adapters.redis")
		auto_ssl:set("renew_check_interval", 172800)		

	}

	init_worker_by_lua_block {
		local json = require("cjson")
		local socket = require("posix.sys.socket")
		local unistd = require("posix.unistd")
		local redis = require("resty.redis")
		local requests = require("resty.requests")
		
			auto_ssl:set("allow_domain", function(domain)
			ngx.log(ngx.ERR, "-------- The domain to check is: ", domain)
			ngx.log(ngx.ERR, "nginx ngx: ", json.encode(ngx.var))

			-- Weed out ip addresses. Cant get ssl for ip addresses
			local ipregex = [=[^([0-9]{1,3}\.)([0-9]{1,3}\.)([0-9]{1,3}\.)([0-9]{1,3})$]=]
			if ngx.re.match(domain, ipregex) then
				-- ngx.log(ngx.ERR, "ngx domain test 1", ngx.re.match(domain, ipregex) )
				-- ngx.log(ngx.ERR, "IP Address Match ", domain)
				return false
			end

			if not domain then
				ngx.log(ngx.ERR, "No Header ")
				-- ngx.exit(499)
				return false
			end

			-- Connect to Redis first and verify FQN as legitimate, return cached results
			local red = redis:new()
			red:set_timeout(1000)

			local ok, err = red:connect("127.0.0.1", 6379)
			if not ok then
				ngx.log(ngx.ERR, "failed to connect to redis: ", err)
				return false
			end

			local res, err = red:hgetall("proxy_Host_"..domain)
			local res = red:array_to_hash(res)

			ngx.log(ngx.ERR, "Redis response FQN domain ", json.encode(res))
			
			-- The entire domain is present in the db, allow the domain
			if res["ip"] then
				return true
			end

			-- New posx socket to check tree
			local decodedRes = nil
			local fd = assert(socket.socket(socket.AF_UNIX, socket.SOCK_STREAM, 0))
			assert(socket.connect(fd, {family = socket.AF_UNIX, path = "/var/run/proxy_lookup.socket"}))
			assert(socket.send(fd, json.encode({domain = domain})))
			while 1 do
				-- ngx.log(ngx.ERR, "While 1 do posx socket")
				local response, err, errnum = socket.recv(fd, 10000)
				ngx.log(ngx.ERR, "posx socket response ", response)
				-- Initial search returns *.domain.com or *.*.domain.com when connected

				decodedRes = json.decode(response)

				if decodedRes then
					break
				end				
			end
			unistd.close(fd)

			ngx.log(ngx.ERR, "decodedRes ", json.encode(decodedRes))

			if (decodedRes["host"] == "none") then
				ngx.log(ngx.ERR, "decodedRes the host is none ")
				return false
			end

			if (decodedRes and decodedRes["host"] ~= "none") then
				ngx.log(ngx.ERR, "The host is not empty ")

				-- This will respond with the wild cards, use wildcard here
				local wildregex = [=[^(\*\.)?+]=]
				local wildcards = ngx.re.match(decodedRes["host"], wildregex)
				local count = #wildcards

				-- Determine qty of subdomains on request
				local subcount = 0
				for word in string.gmatch(domain, '([^.]+)') do
					subcount = subcount + 1
				end

				if( subcount - 2 > count ) then
					ngx.log(ngx.ERR, "more domains than wildcards ")
					return false
				end

				if( count > 0 ) then
					ngx.log(ngx.ERR, "the count is more than 1 ", count)
					-- FQN domain not in redis, determine if domain is active and available on downstream 

					function apicall()
						ngx.log(ngx.ERR, "*********** MAKING HTTP CALL ************ ", domain)

						local uri = "http://"..decodedRes["ip"]
						ngx.log(ngx.ERR, "Querying api for custom domain: ", uri)


						local r, err = requests.request("GET", uri, {
								["Host"] = domain
							} )
						if not r then
								ngx.log(ngx.ERR, "err", err)
						end

						ngx.log(ngx.ERR, "r.status_code: ", r.status_code)
						
						return r
					end

					local http_res = apicall()

					-- ngx.log(ngx.ERR, "http_err: ", http_err)
					ngx.log(ngx.ERR, "json.encode(http_res.status_code): ", http_res.status_code)
					-- ngx.log(ngx.ERR, "json.encode(http_res.body()): ", json.encode(http_res.body()))

					if not http_res then
						ngx.log(ngx.ERR, "failed to request: ", http_err)
						return false
					end
					
					if http_res.status_code == 200 then
						ngx.log(ngx.ERR, "Domain is allowed! status_code code: ", http_res.status_code, " body: ", http_res.body)
						return true
					end

					if http_res.status_code == 301 then
						ngx.log(ngx.ERR, "Domain has been moved to SSL. status_code code: ", http_res.status_code )
						return true
					end
					ngx.log(ngx.ERR, "Request contained an 404 or something... ", domain)
					return false
	
				end
				return false
			end
			return false
		end)

		auto_ssl:init()
		auto_ssl:init_worker()
	}

	ssl_session_cache shared:SSL:10m;
	ssl_session_timeout 10m;

	server {
		listen 127.0.0.1:8999;

		# Increase the body buffer size, to ensure the internal POSTs can always
		# parse the full POST contents into memory.
		client_body_buffer_size 128k;
		client_max_body_size 128k;

		location / {
			content_by_lua_block {
				auto_ssl:hook_server()
			}
		}
	}

	include mime.types;
	default_type application/octet-stream;

	#log_format main '$remote_addr - $remote_user [$time_local] "$request" '
	# '$status $body_bytes_sent "$http_referer" '
	# '"$http_user_agent" "$http_x_forwarded_for"';

	log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
	'$status $body_bytes_sent "$http_referer" '
	'"$http_user_agent" "$http_x_forwarded_for"';


	access_log /var/log/nginx/access.log;
	error_log /var/log/nginx/error.log;

	sendfile on;
	#tcp_nopush on;

	#keepalive_timeout 0;
	keepalive_timeout 65;

	#gzip on;
	include sites-enabled/*;

}
