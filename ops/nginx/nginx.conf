worker_processes 4;

events {
	worker_connections 1024;
}

http {
	map $remote_addr $rt_filtered_ip {
		default $binary_remote_addr;
		98.184.34.4 "";
		167.99.24.104 "";
		134.209.48.248 "";
		10.120.0.12 "";
	}

	limit_req_zone $binary_remote_addr zone=one:10m rate=10r/s;

	client_max_body_size 4g;
	lua_shared_dict auto_ssl 100m;
	lua_shared_dict auto_ssl_settings 64k;

	resolver 8.8.4.4 8.8.8.8 ipv6=off;

	init_by_lua_block {

		local json = require("cjson")
		local socket = require("posix.sys.socket")
		local unistd = require("posix.unistd")
		local redis = require("resty.redis")
		
		auto_ssl = (require "resty.auto-ssl").new()
		auto_ssl:set("storage_adapter", "resty.auto-ssl.storage_adapters.redis")
		auto_ssl:set("renew_check_interval", 172800)		
		auto_ssl:set("allow_domain", function(domain)
			ngx.log(ngx.ERR, "-------- The domain to check is: ", domain)

			-- Weed out ip addresses. Cant get ssl for ip addresses
			local ipregex = [=[^([0-9]{1,3}\.)([0-9]{1,3}\.)([0-9]{1,3}\.)([0-9]{1,3})$]=]
			if ngx.re.match(domain, ipregex) then
				-- ngx.log(ngx.ERR, "ngx domain test 1", ngx.re.match(domain, ipregex) )
				-- ngx.log(ngx.ERR, "IP Address Match ", domain)
				return false
			end

			if not domain then
				ngx.log(ngx.ERR, "No Header ")
				-- ngx.exit(499)
				return false
			end

			-- Connect to Redis first and verify FQN as legitimate, return cached results
			local red = redis:new()
			red:set_timeout(1000)

			local ok, err = red:connect("127.0.0.1", 6379)
			if not ok then
				ngx.log(ngx.ERR, "failed to connect to redis: ", err)
				return false
			end

			local res, err = red:hgetall("proxy_Host_"..domain)
			local res = red:array_to_hash(res)

			ngx.log(ngx.ERR, "Redis response FQN domain ", json.encode(res))
			
			-- The entire domain is present in the db, allow the domain
			if res["ip"] then
				return true
			end

			-- New posx socket
			local fd = assert(socket.socket(socket.AF_UNIX, socket.SOCK_STREAM, 0))
			assert(socket.connect(fd, {family = socket.AF_UNIX, path = "/var/run/proxy_lookup.socket"}))
			ngx.log(ngx.ERR, "posix connection fd ", fd)
			assert(socket.send(fd, json.encode({domain = domain})))
			while 1 do
				ngx.log(ngx.ERR, "While 1 do posx socket")
				local response, err, errnum = socket.recv(fd, 10000)
				ngx.log(ngx.ERR, "posx socket response ", response)
				-- Initial search returns *.domain.com or *.*.domain.com when connected
				if response then
					res = json.decode(response)
					ngx.log(ngx.ERR, "json.encode(res) from posix ", json.encode(res))

					if( res["host"] ~= "none" ) then
						-- This will respond with the wild cards, use wildcard here
						ngx.log(ngx.ERR, "The host is not empty")

						local wildregex = [=[^(\*\.)?+]=]
						local wildcards = ngx.re.match(res["host"], wildregex)
						-- ngx.log(ngx.ERR, "wildcards ", json.encode(wildcards))
						-- ngx.log(ngx.ERR, "how many wildcards ", #wildcards)
						-- Count the wildcards
						local count = #wildcards + 1				
						-- Determine qty of subdomains on request
						local subdomainregex = [=[^(\w+\b\.)?+]=]
						local subdomains = ngx.re.match(domain, subdomainregex)
						local encodedsubs = json.encode(subdomains)
						-- ngx.log(ngx.ERR, "subdomains ", encodedsubs)

						local subcount = #subdomains +1
						if( subcount > count ) then
							return false
						else
							-- FQN domain not in redis, determine if domain is active and available on downstream server
							local httpc, err = require("resty.http").new()
							-- httpc:set_timeout(10000)
							-- httpc:set_proxy_options({http_proxy = true})
	
							local uri = "http://"..domain..":80"
							ngx.log(ngx.ERR, "Querying api for custom domain: ", uri)
							-- local http_res, http_err = httpc:request_uri(uri, {method = "GET"})
							local http_res, http_err = httpc:connect_proxy(uri, "http", res["ip"], "80", false)
							ngx.log(ngx.ERR, "http_res: ", json.encode(http_res))
							ngx.log(ngx.ERR, "http_err: ", http_err)

							if not http_res then
								ngx.log(ngx.ERR, "failed to request: ", http_err)
								return false
							end

							if http_res.status == 200 then
								ngx.log(ngx.ERR, "Domain is allowed! Status code: ", http_res.status, " _id: ", http_res.body)
								return true
							end

							if http_res.status == 301 then
								ngx.log(ngx.ERR, "Domain has been moved to SSL. Status code: ", http_res.status )
								return true
							end

							ngx.log(ngx.ERR, "allow_domain false ", domain)
							httpc:close()

							return false

						end
					end
					break
				end
			end
			unistd.close(fd)

		end)

		auto_ssl:init()
	}

	init_worker_by_lua_block {
		auto_ssl:init_worker()
	}

	ssl_session_cache shared:SSL:10m;
	ssl_session_timeout 10m;

	server {
		listen 127.0.0.1:8999;

		# Increase the body buffer size, to ensure the internal POSTs can always
		# parse the full POST contents into memory.
		client_body_buffer_size 128k;
		client_max_body_size 128k;

		location / {
			content_by_lua_block {
				auto_ssl:hook_server()
			}
		}
	}

	include mime.types;
	default_type application/octet-stream;

	#log_format main '$remote_addr - $remote_user [$time_local] "$request" '
	# '$status $body_bytes_sent "$http_referer" '
	# '"$http_user_agent" "$http_x_forwarded_for"';

	access_log /var/log/nginx/access.log;
	error_log /var/log/nginx/error.log;

	sendfile on;
	#tcp_nopush on;

	#keepalive_timeout 0;
	keepalive_timeout 65;

	#gzip on;
	include sites-enabled/*;

}
