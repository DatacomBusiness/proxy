worker_processes 4;

events {
	worker_connections 1024;
}

http {
	map $remote_addr $rt_filtered_ip {
		default $binary_remote_addr;
		98.184.34.4 "";
		167.99.24.104 "";
		134.209.48.248 "";
		10.120.0.12 "";
	}

	limit_req_zone $binary_remote_addr zone=one:10m rate=10r/s;

	client_max_body_size 4g;
	lua_shared_dict auto_ssl 100m;
	lua_shared_dict auto_ssl_settings 64k;

	resolver 8.8.4.4 8.8.8.8 ipv6=off;

	init_by_lua_block {

		local json = require("cjson")
		local socket = require("posix.sys.socket")
		local unistd = require("posix.unistd")
		local redis = require("resty.redis")
		
		auto_ssl = (require "resty.auto-ssl").new()
		auto_ssl:set("storage_adapter", "resty.auto-ssl.storage_adapters.redis")
		auto_ssl:set("renew_check_interval", 172800)		
		auto_ssl:set("allow_domain", function(domain)
			ngx.log(ngx.ERR, "-------- The domain to check is: ", domain)
			ngx.log(ngx.ERR, "nginx ngx: ", json.encode(ngx.var))

			-- Weed out ip addresses. Cant get ssl for ip addresses
			local ipregex = [=[^([0-9]{1,3}\.)([0-9]{1,3}\.)([0-9]{1,3}\.)([0-9]{1,3})$]=]
			if ngx.re.match(domain, ipregex) then
				-- ngx.log(ngx.ERR, "ngx domain test 1", ngx.re.match(domain, ipregex) )
				-- ngx.log(ngx.ERR, "IP Address Match ", domain)
				return false
			end

			if not domain then
				ngx.log(ngx.ERR, "No Header ")
				-- ngx.exit(499)
				return false
			end

			-- Connect to Redis first and verify FQN as legitimate, return cached results
			local red = redis:new()
			red:set_timeout(1000)

			local ok, err = red:connect("127.0.0.1", 6379)
			if not ok then
				ngx.log(ngx.ERR, "failed to connect to redis: ", err)
				return false
			end

			local res, err = red:hgetall("proxy_Host_"..domain)
			local res = red:array_to_hash(res)

			ngx.log(ngx.ERR, "Redis response FQN domain ", json.encode(res))
			
			-- The entire domain is present in the db, allow the domain
			if res["ip"] then
				return true
			end

			-- New posx socket to check tree
			local fd = assert(socket.socket(socket.AF_UNIX, socket.SOCK_STREAM, 0))
			assert(socket.connect(fd, {family = socket.AF_UNIX, path = "/var/run/proxy_lookup.socket"}))
			-- ngx.log(ngx.ERR, "posix connection fd ", fd)
			assert(socket.send(fd, json.encode({domain = domain})))
			while 1 do
				ngx.log(ngx.ERR, "While 1 do posx socket")
				local response, err, errnum = socket.recv(fd, 10000)
				ngx.log(ngx.ERR, "posx socket response ", response)
				-- Initial search returns *.domain.com or *.*.domain.com when connected

				if (response and response["host"] ~= "none") then
					local response = json.decode(response)
					-- ngx.log(ngx.ERR, "posix json.encode(response) ", json.encode(response))

					-- This will respond with the wild cards, use wildcard here
					ngx.log(ngx.ERR, "The host is not empty")

					local wildregex = [=[^(\*\.)?+]=]
					local wildcards = ngx.re.match(response["host"], wildregex)
					ngx.log(ngx.ERR, "wildcards ", json.encode(wildcards))
					ngx.log(ngx.ERR, "how many wildcards ", #wildcards)
					-- Count the wildcards
					local count = #wildcards
					-- Determine qty of subdomains on request
					-- local subdomainregex = [=[(\w+\.)?]=]
					-- local subdomains, errReg = ngx.re.match(domain, subdomainregex)
					-- local encodedsubs = json.encode(subdomains)

					local subcount = 0
					for word in string.gmatch(domain, '([^.]+)') do
							print(word)
							subcount = subcount + 1
							print(subcount)
					end

					if( subcount - 2 > count ) then
						ngx.log(ngx.ERR, "more domains than wildcards ")
						unistd.close(fd)
						return false
					else

						-- FQN domain not in redis, determine if domain is active and available on downstream 
						local httpc, err = require("resty.http").new()
						-- httpc:set_timeout(10000)
						ngx.log(ngx.ERR, "*********** MAKING HTTP CALL ************ ", domain)

						local uri = "http://192.168.1.52"
						ngx.log(ngx.ERR, "Querying api for custom domain: ", uri)
						local http_res, http_err = httpc:request_uri(uri, 
						{
							method = "GET",
							headers = {
								["Host"] = domain
							}
						})
						ngx.log(ngx.ERR, "http_err: ", http_err)
						ngx.log(ngx.ERR, "json.encode(http_res.status): ", http_res.status)
						ngx.log(ngx.ERR, "json.encode(http_res.headers): ", json.encode(http_res.headers))
						ngx.log(ngx.ERR, "json.encode(http_res.body): ", json.encode(http_res.body))


						if not http_res then
							ngx.log(ngx.ERR, "failed to request: ", http_err)
							unistd.close(fd)
							httpc:close()
							return false
						end

						if http_res.status == 200 then
							ngx.log(ngx.ERR, "Domain is allowed! Status code: ", http_res.status, " body: ", http_res.body)
							unistd.close(fd)
							httpc:close()
							return true
						end

						if http_res.status == 301 then
							ngx.log(ngx.ERR, "Domain has been moved to SSL. Status code: ", http_res.status )
							unistd.close(fd)
							httpc:close()
							return true
						end

						ngx.log(ngx.ERR, "Request was a 404 or something... ", domain)
						unistd.close(fd)
						httpc:close()
						return false

					end
				end
			end
			unistd.close(fd)

		end)

		auto_ssl:init()
	}

	init_worker_by_lua_block {
		auto_ssl:init_worker()
	}

	ssl_session_cache shared:SSL:10m;
	ssl_session_timeout 10m;

	server {
		listen 127.0.0.1:8999;

		# Increase the body buffer size, to ensure the internal POSTs can always
		# parse the full POST contents into memory.
		client_body_buffer_size 128k;
		client_max_body_size 128k;

		location / {
			content_by_lua_block {
				auto_ssl:hook_server()
			}
		}
	}

	include mime.types;
	default_type application/octet-stream;

	#log_format main '$remote_addr - $remote_user [$time_local] "$request" '
	# '$status $body_bytes_sent "$http_referer" '
	# '"$http_user_agent" "$http_x_forwarded_for"';

	log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
	'$status $body_bytes_sent "$http_referer" '
	'"$http_user_agent" "$http_x_forwarded_for"';


	access_log /var/log/nginx/access.log;
	error_log /var/log/nginx/error.log;

	sendfile on;
	#tcp_nopush on;

	#keepalive_timeout 0;
	keepalive_timeout 65;

	#gzip on;
	include sites-enabled/*;

}
