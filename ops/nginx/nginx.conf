worker_processes 4;

events {
	worker_connections 1024;
}

http {
	map $remote_addr $rt_filtered_ip {
		default $binary_remote_addr;
		98.184.34.4 "";
		167.99.24.104 "";
		134.209.48.248 "";
		10.120.0.12 "";
	}

	limit_req_zone $binary_remote_addr zone=one:10m rate=10r/s;

	client_max_body_size 4g;
	lua_shared_dict auto_ssl 100m;
	lua_shared_dict auto_ssl_settings 64k;

	resolver 8.8.4.4 8.8.8.8 ipv6=off;

	init_by_lua_block {

		local json = require("cjson")
		local socket = assert(require "socket.unix"())
		local redis = require("resty.redis")
		
		auto_ssl = (require "resty.auto-ssl").new()
		auto_ssl:set("storage_adapter", "resty.auto-ssl.storage_adapters.redis")
		auto_ssl:set("renew_check_interval", 172800)		
		auto_ssl:set("allow_domain", function(domain)
			ngx.log(ngx.ERR, "The domain to check is: ", domain)

			-- Weed out ip addresses. Cant get ssl for ip addresses
			local ipregex = [=[^([0-9]{1,3}\.)([0-9]{1,3}\.)([0-9]{1,3}\.)([0-9]{1,3})$]=]
			if ngx.re.match(domain, ipregex) then
				-- ngx.log(ngx.ERR, "ngx domain test 1", ngx.re.match(domain, ipregex) )
				-- ngx.log(ngx.ERR, "IP Address Match ", domain)
				return false
			end

			if not domain then
				ngx.log(ngx.ERR, "No Header ")
				-- ngx.exit(499)
				return false
			end

			-- Connect to Redis first and verify FQN as legitimate
			local red = redis:new()
			red:set_timeout(1000)

			local ok, err = red:connect("127.0.0.1", 6379)
			if not ok then
				ngx.log(ngx.ERR, "failed to connect to redis: ", err)
				return false
			end

			local res, err = red:hgetall("proxy_Host_"..domain)
			local res = red:array_to_hash(res)

			local firstResponse = json.encode(res)
			ngx.log(ngx.ERR, "Redis response FQN domain ", firstResponse)
			
			-- The entire domain is present in the db, allow the domain
			if res["ip"] then
				return true
			end

			-- Connect to the socket and search for domain from lookuptree
			assert(socket:settimeout(.5))
			local status, err = pcall(function() 
				assert(socket:connect("/var/run/proxy_lookup.socket")) 
			end)
			ngx.log(ngx.ERR, "socket.unix connection status ", status)
			ngx.log(ngx.ERR, "socket.unix connection err ", err)
			if status then 
				ngx.log(ngx.ERR, "socket.unix connection is made ")
				assert(socket:send(json.encode({domain = domain})))
				while 1 do
					ngx.log(ngx.ERR, "While 1 do ")
					local s, status, partial = socket:receive()
					ngx.log(ngx.ERR, "Initial FQN search partial s ", s)
					ngx.log(ngx.ERR, "Initial FQN search partial status ", status)
					ngx.log(ngx.ERR, "Initial FQN search partial partial ", partial)
					-- Initial search returns *.domain.com or *.*.domain.com when connected
					if partial then
						res = json.decode(partial)
						socket:close()
						break
					end
				end
			else
				ngx.log(ngx.ERR, "socket connection failed")
				socket:close()
				-- return false
			end

			-- FQN domain not in redis, determine if domain is active and available via http
			local httpc = require("resty.http").new()
			httpc:set_timeout(3000)
			local connection = json.encode(httpc)
			ngx.log(ngx.ERR, "httpc connection: ",  connection)
			-- ngx.log(ngx.ERR, "os.getenv('ALLOW_DOMAIN_API')..domain ", os.getenv("ALLOW_DOMAIN_API")..domain)

			-- local uri = os.getenv("ALLOW_DOMAIN_API")..domain
			local uri = "http://"..domain
			ngx.log(ngx.ERR, "Querying api for custom domain: ", uri)
			local http_res, http_err = httpc:request_uri(uri, {method = "GET"})

			if not http_res then
				ngx.log(ngx.ERR, "failed to request: ", http_err)
				return false
			end

			if http_res.status == 200 then
				ngx.log(ngx.ERR, "Domain is allowed! Status code: ", http_res.status, " _id: ", http_res.body)
				return true
			end

			if http_res.status == 301 then
				ngx.log(ngx.ERR, "Domain has been moved to SSL. Status code: ", http_res.status )
				return true
			end

			if http_res.status == 404 then
				ngx.log(ngx.ERR, "Domain not found. Status code: ", http_res.status)
				return false
			end

			ngx.log(ngx.ERR, "Unexpected http_response from API. Status code: ", http_res.status)

			-- Find out how many stars the domain has in redis, then allow up to that many subdomains to be approved.
			-- ngx.log(ngx.ERR, "res partial", json.encode(res))

			-- if not res["ip"] then
				-- ngx.log(ngx.ERR, "No Host Found ", domain)
				-- ngx.exit(406)
				-- return false			
			-- end

			ngx.log(ngx.ERR, "allow_domain false ", domain)
			return false

		end)

		auto_ssl:init()
	}

	init_worker_by_lua_block {
		auto_ssl:init_worker()
	}

	ssl_session_cache shared:SSL:10m;
	ssl_session_timeout 10m;

	server {
		listen 127.0.0.1:8999;

		# Increase the body buffer size, to ensure the internal POSTs can always
		# parse the full POST contents into memory.
		client_body_buffer_size 128k;
		client_max_body_size 128k;

		location / {
			content_by_lua_block {
				auto_ssl:hook_server()
			}
		}
	}

	include mime.types;
	default_type application/octet-stream;

	#log_format main '$remote_addr - $remote_user [$time_local] "$request" '
	# '$status $body_bytes_sent "$http_referer" '
	# '"$http_user_agent" "$http_x_forwarded_for"';

	access_log /var/log/nginx/access.log;
	error_log /var/log/nginx/error.log;

	sendfile on;
	#tcp_nopush on;

	#keepalive_timeout 0;
	keepalive_timeout 65;

	#gzip on;
	include sites-enabled/*;

}
